/* Copyright 2022 Jose Pablo Ramirez <jp.ramangulo@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// userspace code
#include "anomalocaridid.h"
#include "encoder.h"
#include "host.h"
#include "keycodes.h"
#include "quantum.h"

#include QMK_KEYBOARD_H

#define FOREACH_LAYER(F)        \
    F(BASE) /* Default layer */ \
    F(FUNC) /* Function Keys */ \
    F(MDIA) /* Media layer */   \
    F(MOUS) /* Mouse layer */

#define GENERATE_ENUM(LAYER) LAYER,
#define STRINGIFY(LAYER) #LAYER,

enum layers {
    FOREACH_LAYER(GENERATE_ENUM) // Generate layer enum
    KEYMAP_LAYER_MAX,            // Not a layer, just for convenience in working with layers
};

static const char *layer_names[] = {FOREACH_LAYER(STRINGIFY)};

enum custom_keycodes_keymap {
    ENC_LEFT = USER_SAFE_RANGE,
    ENC_RIGHT,
    ENC_TOGGLE,
};

// String with an arbitrarily chosen unused character to mark that the QMK LOGO character should be used
// This is necessary because the QMK logo is on 0x00, which is NUL and inconvenient to use in strings
static const char QMK_LOGO_PLACEHOLDER[] = "\x20";

// clang-format off
static const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [BASE] = LAYOUT(
                        KC_NUM,
        KC_P7,   KC_P8, KC_P9,
        KC_P4,   KC_P5, KC_P6,
        KC_P1,   KC_P2, KC_P3,
        KC_PDOT, KC_P0, KC_PENT
    ),
    [FUNC] = LAYOUT(
                        ENC_TOGGLE,
        KC_F1,  KC_F2,  KC_F3,
        KC_F4,  KC_F5,  KC_F6,
        KC_F7,  KC_F8,  KC_F9,
        KC_F10, KC_F11, KC_F12
    ),
    [MOUS] = LAYOUT(
                          ENC_TOGGLE,
        MS_BTN1, MS_BTN3, MS_BTN2,
        MS_WHLL, MS_UP,   MS_WHLR,
        MS_LEFT, MS_DOWN, MS_RGHT,
        MS_ACL0, MS_ACL1, MS_ACL2
    ),
    [MDIA] = LAYOUT(
                          ENC_TOGGLE,
        KC_MPRV, KC_MPLY, KC_MNXT,
        KC_MRWD, KC_STOP, KC_MFFD,
        RM_PREV, RM_TOGG, RM_NEXT,
        CK_TOGG, AU_TOGG, QK_MAKE
    ),
};

// Helper macro to define keymap guides
#define GUIDE(     \
              k0C, \
    k1A, k1B, k1C, \
    k2A, k2B, k2C, \
    k3A, k3B, k3C, \
    k4A, k4B, k4C  \
)                  \
{                  \
   {"",  "",  k0C},\
   {k1A, k1B, k1C},\
   {k2A, k2B, k2C},\
   {k3A, k3B, k3C},\
   {k4A, k4B, k4C},\
}

// Helper macro to not repeat layer guide definitions where applicable
#define SHARED_LAYER_GUIDES                      \
[MOUS] = GUIDE(                                  \
                              "Scroll Toggle",   \
    "LClk",      "MClk",      "RClk",            \
    "Wheel\x1B", "Mouse\x18", "Wheel\x1A",       \
    "Mouse\x1B", "Mouse\x19", "Mouse\x1A",       \
    "Slow",      "Med",       "Fast"             \
),                                               \
[MDIA] = GUIDE(                                  \
                            "VolCtrlTog",        \
    "|\x11",    "\x13",     "\x10|",             \
    "\x11\x11", "\x04",     "\x10\x10",          \
    "RGB|\x11", "RGB Tog",  "RGB\x10|",          \
    "Clk Tog",  "\x0E Tog", QMK_LOGO_PLACEHOLDER \
),                                               

// Helpful guide for each layer to render to display
static const char* PROGMEM keymap_guide[][MATRIX_ROWS][MATRIX_COLS] = {
    [BASE] = GUIDE(
                        "Num Lock",
        "Home", "\x18", "PageUp",
        "\x1B", "",     "\x1A",
        "End",  "\x19", "PageDn",
        "Del",  "Ins",  "Enter"
    ),
    [FUNC] = GUIDE(
                      "F+12 Toggle",
        "F1",  "F2",  "F3",
        "F4",  "F5",  "F6",
        "F7",  "F8",  "F7",
        "F10", "F11", "F12"
    ),
    SHARED_LAYER_GUIDES
};

// Alternate guides to display when alt_encoder_enable = true or Num Lock is enabled
static const char* PROGMEM alt_keymap_guide[][MATRIX_ROWS][MATRIX_COLS] = {
    [BASE] = GUIDE(
                  "Num Lock",
        "7", "8", "9",
        "4", "5", "6",
        "1", "2", "3",
        ".", "0", "Enter"
    ),
    [FUNC] = GUIDE(
                      "F+12 Toggle",
        "F13", "F14", "F15",
        "F16", "F17", "F18",
        "F19", "F20", "F21",
        "F22", "F23", "F24"
    ),
    SHARED_LAYER_GUIDES
};
// clang-format on

const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
    [BASE]                         = {ENCODER_CCW_CW(ENC_LEFT, ENC_RIGHT)},
    [FUNC... KEYMAP_LAYER_MAX - 1] = {ENCODER_CCW_CW(_______, _______)},
};

// Used in conjunction with ENC_LEFT, ENC_RIGHT, and ENC_TOGGLE to provide alternative buttons
static const uint16_t PROGMEM alt_encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
    [BASE] = {ENCODER_CCW_CW(XXXXXXX, XXXXXXX)},
    [FUNC] = {ENCODER_CCW_CW(XXXXXXX, XXXXXXX)},
    [MOUS] = {ENCODER_CCW_CW(MS_WHLD, MS_WHLU)},
    [MDIA] = {ENCODER_CCW_CW(KC_VOLD, KC_VOLU)},
};

// Whether to redraw the guide on the display
static bool redraw_layout_guide = false;
// Mapping of which keys are pressed
static bool pressed_keys[MATRIX_ROWS][MATRIX_COLS] = {{false}};
// Whether to use alternate encoder functions
static bool use_alt_encoder = false;

bool process_record_keymap(uint16_t keycode, keyrecord_t *record) {
    uint16_t layer = get_highest_layer(layer_state);

    // Mark if key is pressed
    pressed_keys[record->event.key.row][record->event.key.col] = record->event.pressed;
    // Ensure layout is redrawn
    redraw_layout_guide = true;

    switch (keycode) {
        case KC_F1 ... KC_F12:
            if (record->event.pressed) {
                // If alternate map is enabled, add 12 to each function key
                // e.g. F1 -> F13, F2 -> 14, ..., F12 -> F24
                if (use_alt_encoder) {
                    tap_code(keycode + (KC_F13 - KC_F1));
                    return false;
                }
            }
            break;
        case ENC_LEFT:
            if (record->event.pressed) {
                if (use_alt_encoder) {
                    tap_code(alt_encoder_map[layer][0][1]);
                } else {
                    // Go to previous layer, wrapping around
                    layer_move(layer == BASE ? KEYMAP_LAYER_MAX - 1 : layer - 1);
                }
            }
            return false;
        case ENC_RIGHT:
            if (record->event.pressed) {
                if (use_alt_encoder) {
                    tap_code(alt_encoder_map[layer][0][0]);
                } else {
                    // Go to next layer, wrapping around
                    layer_move((layer + 1) % KEYMAP_LAYER_MAX);
                }
            }
            return false;
        case ENC_TOGGLE:
            if (record->event.pressed) {
                use_alt_encoder ^= 1;
            }
            return false;
    }

    return true;
}

static void render_qmk_logo(void) {
    // clang-format off
    static const char PROGMEM qmk_logo[] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x3f, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,
      0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x03, 0x83, 0x83, 0x83, 0x83, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe,
      0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0xfe, 0xfe, 0xfe, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x83, 0x83, 0x83, 0x83, 0x03,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x81, 0x83, 0x83, 0x83, 0x83, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x83, 0x83, 0x83, 0x83, 0x81,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x01, 0x07, 0x1f, 0x3f, 0x7f, 0x7e, 0xf8, 0xf0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xff, 0xff,
      0xff, 0xff, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xf0, 0xf8, 0x7e, 0x7f, 0x3f, 0x1f, 0x07, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xc0, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff, 0xff,
      0xff, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc0,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xfc, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xfc, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc,
      0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfc,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    // clang-format on

    oled_write_raw_P(qmk_logo, sizeof(qmk_logo));
}

void keyboard_post_init_user(void) {
    rgb_matrix_mode_noeeprom(RGB_MATRIX_MULTISPLASH);
    rgb_matrix_sethsv_noeeprom(HSV_MAGENTA);
}

layer_state_t layer_state_set_user(layer_state_t state) {
    redraw_layout_guide = true;
    return state;
}

bool led_update_user(led_t led_state) {
    if (!led_state.num_lock) {
        // Ensure layout guide is updated when num lock is deactivated
        redraw_layout_guide = true;
    }
    return true;
}

void render_layout_guide(void) {
    // Ensure that clearing and rendering is only done if there are changes to render
    if (redraw_layout_guide) {
        redraw_layout_guide = false;
        oled_clear();

        uint16_t layer = get_highest_layer(layer_state);
        oled_write("Layer:", false);
        oled_write(get_u8_str(layer, ' '), false);
        oled_write_char(0x10, true);
        oled_write(layer_names[layer], true);
        oled_write_char(0x10, false);

        uint8_t line_length = oled_max_chars();

        if (use_alt_encoder) {
            oled_set_cursor(line_length - 1, 0);
            oled_write_char('*', false);
        }

        // Use alternate layout guide when either alternate encoder function is enabled
        // or the current layer is the base layer and Num Lock is enabled
        bool use_alt_guide = use_alt_encoder || (layer == BASE && host_keyboard_led_state().num_lock);

        for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
            // The row on the display to draw the labels on
            uint8_t display_row = row + 2;

            for (uint8_t col = 0; col < MATRIX_COLS; col++) {
                const char *key_label = use_alt_guide ? alt_keymap_guide[layer][row][col] : keymap_guide[layer][row][col];
                // The place to start writing the label if it is to end right at the end of the row
                uint8_t right_aligned_start = line_length - strlen(key_label);

                switch (col) {
                    // middle of row
                    case 1:
                        oled_set_cursor(right_aligned_start / 2, display_row);
                        break;
                    // right of row
                    // NOTE: will be at very end of row/page so advancing page is not necessary
                    case 2:
                        oled_set_cursor(right_aligned_start, display_row);
                        break;
                }

                if (key_label[0] == QMK_LOGO_PLACEHOLDER[0]) {
                    oled_write_char(0x00, pressed_keys[row][col]);
                } else {
                    oled_write(key_label, pressed_keys[row][col]);
                }
            }
        }
    }
}

static uint16_t boot_logo_timer = 0;

bool oled_task_user(void) {
    if (boot_logo_timer < 1000) {
        render_qmk_logo();
        boot_logo_timer = timer_read();
        return true;
    }

    render_layout_guide();

    return true;
}
